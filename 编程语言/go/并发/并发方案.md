## 并发

### 单进程

很久以前，主流处理器都是单核的，操作系统的基本调度与执行单元是进程。单进程应用的情况下，用户层应用、操作系统进程以及处理器之间的关系是这样的：

![[Pasted image 20230217082336.png]]

每个单进程应用对应一个操作系统进程，操作系统内的多个进程按时间片大小，被轮流调度到仅有的一颗单核处理器上执行。换句话说，这颗单核处理器在某个时刻只能执行一个进程对应的程序代码，两个进程不存在并行执行的可能

### 多进程

应用通过 fork 等系统调用创建多个子进程，共同实现应用的功能。多进程应用的情况下，用户层应用、操作系统进程以及处理器之间的关系是这样的：

![[Pasted image 20230217082349.png]]

应用设计者将应用内部划分为多个模块，每个模块用一个进程承载执行，每个模块都是一个单独的执行流，这样应用内部就有了多个独立的代码执行流。但如果只有一颗单核处理器，这些进程依旧无法并行执行，都得逐个按时间片被操作系统调度到处理器上执行

从结构上来看，多进程要比单进程更为清晰简洁，可读性与可维护性也更好。这种将程序分成多个可独立执行的部分的结构化程序的设计方法，就是并发设计。采用了并发设计的应用也可以看成是一组独立执行的模块的组合

不过，进程并不适合用于承载采用了并发设计的应用的模块执行流。因为进程是操作系统中资源拥有的基本单位，它不仅包含应用的代码和数据，还有系统级的资源，比如文件描述符、内存地址空间等等。这导致它的创建、切换与撤销的代价都很大

### 多线程

线程就是运行于进程上下文中的更轻量级的执行流。同时随着处理器技术的发展，多核处理器硬件成为了主流，这让真正的并行成为了可能，于是主流的应用设计模型变成了这样：

![[Pasted image 20230217082404.png]]

基于线程的应用通常采用单进程多线程的模型，一个应用对应一个进程，应用通过并发设计将自己划分为多个模块，每个模块由一个线程独立承载执行。多个线程共享这个进程所拥有的资源，但线程作为执行单元可被独立调度到处理器上运行

线程的创建、切换与撤销的代价相对于进程是要小得多。当这个应用的多个线程同时被调度到不同的处理器核上执行时，这个应用就是是并行的

并发是在应用设计与实现阶段要考虑的问题。并发考虑的是如何将应用划分为多个互相配合的、可独立执行的模块的问题。采用并发设计的程序并不一定是并行执行的。在不满足并行必要条件的情况下，即便是采用并发设计的程序，依旧不可以并行执行。而在满足并行必要条件的情况下，采用并发设计的程序是可以并行执行的

在传统编程语言中，基于多线程模型的应用设计就是一种典型的并发程序设计。但传统编程语言并非面向并发而生，没有对并发设计提供过多的帮助。并且，这些语言多以操作系统线程作为承载分解后的代码片段的执行单元，由操作系统执行调度。这种传统支持并发的方式有很多不足：

1. 复杂
	1. 创建容易退出难，一旦涉及线程的退出，就要考虑新创建的线程是否要与主线程分离，还是需要主线程等待子线程终止并获取其终止状态。又或者是否需要在新线程中设置取消点来保证被主线程取消的时候能顺利退出
	2. 并发执行单元间的通信困难且易错。一旦涉及共享内存，就会用到各种锁互斥机制
	3. 线程栈大小也需要设定，开发人员需要选择使用默认的，还是自定义设置
2. 难于规模化。线程的使用代价虽然已经比进程小了很多，但还是不能大量创建线程，因为除了每个线程占用的资源不小之外，操作系统调度切换线程的代价也不小。对于很多网络服务程序来说，由于不能大量创建线程，只能选择在少量线程里做网络多路复用的方案，也就是使用 epoll 这套机制，给开发人员带来不小的心智负担

### Go 的并发

Go 实现了 goroutine 这一由 Go 运行时负责调度的、轻量的用户级线程，为并发程序设计提供原生支持。这一方案有以下优势：

1.  资源占用小，每个 goroutine 的初始栈大小仅为 2k
2.  goroutine 上下文切换在用户层完成，开销更小
3.  在语言层面而不是通过标准库提供，一退出就会被回收或销毁，开发体验更佳
4.  语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑

无论是 Go 自身运行时代码还是用户层 Go 代码，都无一例外地运行在 goroutine 中。创建 goroutine 后，go 关键字不会返回唯一标识 goroutine 的 id。另外，和线程一样，一个应用内部启动的所有 goroutine 共享进程空间的资源，如果多个 goroutine 访问同一块内存数据，将会存在竞争，需要进行 goroutine 间的同步

goroutine 的使用代价很低，在多数情况下， 不需要考虑对 goroutine 的退出进行控制。goroutine 的执行函数的返回，就意味着 goroutine 退出。如果 main goroutine 退出了，那么也意味着整个应用程序的退出。此外，goroutine 执行的函数或方法即便有返回值，Go 也会忽略这些返回值。所以，如果要获取 goroutine 执行后的返回值，需要另行考虑其他方法

#### goroutine 通信

传统的编程语言并非面向并发而生的，所以他们面对并发的逻辑多是基于操作系统的线程。并发的执行单元之间的通信，利用的也是操作系统提供的线程或进程间通信的原语，比如：共享内存、信号、管道 、消息队列、套接字等

在这些通信原语中，使用最多、最广泛的是结合了线程同步原语的共享内存方式，可以说传统语言的并发模型是基于对内存的共享的。不过，这种传统的基于共享内存的并发模型很难用，且易错，尤其是在大型或复杂程序中，要花费大量心思设计线程间的同步机制，并且在设计同步机制的时候，还要考虑多线程间复杂的内存管理，以及如何防止死锁等情况

Go 语言在新并发模型设计中借鉴了 CSP 并发模型：

![[Pasted image 20230217082455.png]]

这里的 P 并不一定与操作系统的进程或线程划等号。在 Go 中，与 Process 对应的是 goroutine。为了实现 CSP 并发模型中的输入和输出原语，Go 引入了 goroutine 之间的通信原语 channel。goroutine 可以从 channel 获取输入数据， 再将处理后得到的结果数据通过 channel 输出。通过 channel 将 goroutine 组合连接在一起

虽然 CSP 模型已经成为 Go 语言支持的主流并发模型，但 Go 也支持传统的、基于共享内存的并发模型，并提供了基本的低级别同步原语