## 进程

1.  分配系统资源（CPU 时间、内存等）基本单位
2.  有独立的内存空间，切换开销大

![[Pasted image 20230217081813.png]]

## 内存访问

CPU 上有个 MemoryManagementUnit（MMU）单元
CPU 把虚拟地址给 MMU，MMU 去物理内存中查询页表，得到实际的物理地址
CPU 维护一份缓存 TranslationLookasideBuffer（TLB），缓存虚拟地址和物理地址的映射关系

![[Pasted image 20230217081826.png]]

### 进程切换

#### 直接开销

1.  切换页表全局目录（PGD）
2.  切换内核态堆栈
3.  切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）
4.  刷新 TLB
5.  系统调度器的代码执行

#### 间接开销

CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多

## 线程

1.  进程的一个执行流，是 CPU 调度并能独立运行的的基本单位
2.  同一进程中的多线程共享内存空间，线程切换代价小
3.  多线程通信方便
4.  线程跟进程，在 linux 中都以 task_struct 描述，从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共享了地址空间和信号处理函数

![[Pasted image 20230217081852.png]]

### 线程切换

1.  线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换
2.  一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程切换，主要节省了虚拟地址空间的切换

### 用户线程

无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成

![[Pasted image 20230217081907.png]]

## 协程

传统的编程语言多是基于线程模型的，由应用程序负责创建线程，操作系统负责调度线程。这种传统支持并发的方式有很多不足，为了解决这些问题，Go 语言中的并发实现，使用了 Goroutine，代替了操作系统的线程，也不再依靠操作系统调度

Goroutine 占用的资源非常小，每个 Goroutine 栈的默认大小默认是 2KB（线程占用空间是 8M）。而且，Goroutine 调度的切换也不用陷入操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 Goroutine

### Goroutine 调度器

Go 程序是用户层程序，它本身就是整体运行在一个或多个操作系统线程上的。Goroutine 调度器的任务就是将 Goroutine 按照一定算法放到不同的操作系统线程中去执行

Go 1.0 版本中，Go 开发团队实现了一个简单的 Goroutine 调度器。在这个调度器中，每个 Goroutine 对应于运行时中的一个抽象结构 G，操作系统线程被抽象为另外一个结构 M。调度器的工作就是将 G 调度到 M 上去运行。为了更好地控制程序中活跃的 M 的数量，调度器引入了 GOMAXPROCS 变量来表示 Go 调度器可见的处理器的最大数量

这个模型限制了 Go 并发程序的伸缩性，尤其是对那些有高吞吐或并行计算需求的服务程序。这个问题主要体现在这几个方面：

1.  单一全局互斥锁和集中状态存储的存在，导致所有 Goroutine 相关操作，比如创建、重新调度等，都要上锁
2.  Goroutine 传递问题：M 经常在 M 之间传递可运行的 Goroutine，这导致调度延迟增大，也增加了额外的性能损耗
3.  每个 M 都做内存缓存，导致内存占用过高，数据局部性较差
4.  由于系统调用而形成的频繁的工作线程阻塞和解除阻塞，导致额外的性能损耗

Go 1.1 版本中实现了 GPM 调度模型和 work stealing 算法，模型如下图所示：

![[Pasted image 20230217081934.png]]

P 是一个逻辑 Proccessor，每个 G 要想真正运行起来，首先需要被分配一个 P，也就是进入到 P 的本地运行队列中。对于 G 来说，P 就是运行它的 CPU。但从 Go 调度器的视角来看，真正的 CPU 是 M，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来

GPM 模型的实现算是 Go 调度器的一大进步，但仍然存在一个问题：不支持抢占式调度。这导致一旦某个 G 中出现死循环的代码逻辑，那么 G 将永久占用分配给它的 P 和 M，而位于同一个 P 中的其他 G 将得不到调度，出现饿死的情况。更为严重的是，当只有一个 P 时，整个 Go 程序中的其他 G 都将饿死。

Go 1.2 中实现了基于协作的抢占式调度。Go 编译器在每个函数或方法的入口处加上了一段额外的代码，让运行时有机会在这段代码中检查是否需要执行抢占调度。这种解决方案只能说局部解决了饿死问题，只在有函数调用的地方才能插入抢占代码，对于没有函数调用而是纯算法循环计算的 G，调度器依然无法抢占

Go 1.14 版本增加了对非协作的抢占式调度的支持，这种抢占式调度是基于系统信号的，也就是通过向线程发送信号的方式来抢占正在运行的 Goroutine。除此之外，Goroutine 的调度器还有一些小的优化改动，比如通过文件 I/O poller 减少 M 的阻塞等

Go 运行时已经实现了 netpoller，这使得即便 G 发起网络 I/O 操作，也不会导致 M 被阻塞（仅阻塞 G），也就不会导致大量线程（M）被创建出来。

对于文件 I/O 操作来说，一旦阻塞，那么 M 将进入挂起状态，等待 I/O 返回后被唤醒。这种情况下 P 将与挂起的 M 分离，再选择一个处于空闲状态的 M。如果此时没有空闲的 M，就会新创建一个 M，所以，这种情况下，大量 I/O 操作仍然会导致大量线程被创建

为了解决这个问题，Go 1.9 版本增加了一个针对文件 I/O 的 Poller 功能，在 G 操作那些支持监听的文件描述符时，仅会阻塞 G，而不会阻塞 M。不过这个功能依然不能对常规文件有效，常规文件是不支持监听的

### GMP 模型

G 代表 Goroutine，存储了 Goroutine 的执行栈信息、Goroutine 状态以及 Goroutine 的任务函数等，而且 G 对象是可以重用的

P 代表逻辑 processor，P 的数量决定了系统内最大可并行的 G 的数量，P 的最大作用还是其拥有的各种 G 对象队列、链表、一些缓存和状态

M 代表着真正的执行计算资源。在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础

Goroutine 调度器的目标，就是公平合理地将各个 G 调度到 P 上运行。只要 G 调用函数，Go 运行时就有了抢占 G 的机会。Go 程序启动时，运行时会去启动一个名为 sysmon 的 M，这个 M 的特殊之处在于它不需要绑定 P 就可以运行，这个 M 在整个 Go 程序的运行过程中至关重要。sysmon 每 20us~10ms 启动一次，主要完成了这些工作：

1.  释放闲置超过 5 分钟的 span 内存
2.  如果超过 2 分钟没有垃圾回收，强制执行
3.  将长时间未处理的 netpoll 结果添加到任务队列
4.  向长时间运行的 G 任务发出抢占调度
5.  收回因 syscall 长时间阻塞的 P

如果一个 G 任务运行 10ms，sysmon 就会认为它的运行时间太久而发出抢占式调度的请求。一旦 G 的抢占标志位被设为 true，那么等到这个 G 下一次调用函数或方法时，运行时就可以将 G 抢占并移出运行状态，放入队列中，等待下一次被调度

除了这个常规调度之外，还有两个特殊情况下 G 的调度方法：

1.  如果 G 被阻塞在某个 channel 操作或网络 I/O 操作上时，G 会被放置到某个等待队列中，而 M 会尝试运行 P 的下一个可运行的 G。如果这个时候 P 没有可运行的 G 供 M 运行，那么 M 将解绑 P，并进入挂起状态。当 I/O 操作完成或 channel 操作完成，在等待队列中的 G 会被唤醒，标记为可运行，并被放入到某 P 的队列中，绑定一个 M 后继续执行
2.  如果 G 被阻塞在某个系统调用上，那么不光 G 会阻塞，执行这个 G 的 M 也会解绑 P，与 G 一起进入挂起状态。如果此时有空闲的 M，那么 P 就会和它绑定，并继续执行其他 G；如果没有空闲的 M，但仍然有其他 G 要去执行，那么 Go 运行时就会创建一个新 M。当系统调用返回后，阻塞在这个系统调用上的 G 会尝试获取一个可用的 P，如果没有可用 的 P，那么 G 会被标记为 runnable，之前的那个挂起的 M 将再次进入挂起状态

![[Pasted image 20230217082014.png]]

#### Process

![[Pasted image 20230217082026.png]]

\_Pidle：处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空
\_Prunning：被线程 M 持有，并且正在执行用户代码或者调度器
\_Psyscall：没有执行用户代码，当前线程陷入系统调用
\_Pgcstop：被线程 M 持有，当前处理器由于垃圾回收被停止
\_Pdead：当前处理器已经不被使用

#### Goroutine

![[Pasted image 20230217082129.png]]

\_Gidle：刚刚被分配并且还没有被初始化，值为 0，为创建 goroutine 后的默认值
\_Grunnable：没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个 P 的本地队列或全局队列中
\_Grunning：正在执行代码的 goroutine，拥有栈的所有权
\_Gsyscall：正在执行系统调用，拥有栈的所有权，与 P 脱离，但是与某个 M 绑定，会在调用结束后被分配到运行队列
\_Gwaiting：被阻塞的 goroutine，阻塞在某个 channel 的发送或者接收队列
\_Gdead：当前 goroutine 未被使用，没有执行代码，可能有分配的栈，分布在空闲列表 gFree，可能是一个刚刚初始化的 goroutine，也可能是执行了 goexit 退出的 goroutine
\_Gcopystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在
\_Gscan：GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在

##### Goroutine 创建

1.  获取或者创建新的 Goroutine 结构体：从处理器的 gFree 列表中查找空闲的 Goroutine；如果不存在空闲的 Goroutine，会通过 runtime.malg 创建一个栈大小足够的新结构体
2.  将函数传入的参数移到 Goroutine 的栈上
3.  更新 Goroutine 调度相关的属性，更新状态为 _Grunnable
4.  返回的 Goroutine 会存储到全局变量 allgs 中

##### Goroutine 入队

1.  Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务
2.  当处理器的本地运行队列已经没有剩余空间时（256），就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 runtime.runqputslow 添加到调度器持有的全局运行队列上

##### Goroutine 调度

1.  为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率（1/61）会从全局的运行队列中查找对应的 Goroutine
2.  从处理器本地的运行队列中查找待执行的 Goroutine
3.  如果前两种方法都没有找到 Goroutine，会通过 runtime.findrunnable 进行阻塞地查找 Goroutine：
	1.  从本地运行队列、全局运行队列中查找
	2.  从网络轮询器中查找是否有 Goroutine 等待运行
	3.  通过 runtime.runqsteal 尝试从其他随机的处理器中窃取一半待运行的 Goroutine
