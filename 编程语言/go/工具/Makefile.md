Go 项目的 Makefile 应该实现以下功能：

1.  格式化代码、静态代码检查、单元测试、代码构建、文件清理、帮助等等
2.  如果通过 docker 部署，还需要有 docker 镜像打包功能。因为 Go 是跨平台的语言，所以构建和 docker 打包命令，还要能够支持不同的 CPU 架构和平台
3.  为了能够更好地控制 Makefile 命令的行为，还需要支持 Options
4.  为了方便查看 Makefile 集成的功能，需要支持 help 命令。help 命令最好通过解析 Makefile 文件来输出集成的功能

## 结构设计

所有管理功能都集成在一个 Makefile 中，可能会导致 Makefile 很大，难以阅读和维护。建议采用分层的设计方法，根目录下的 Makefile 聚合所有的 Makefile 命令，具体实现则按功能分类，放在另外的 Makefile 中

![[Pasted image 20230217082552.png]]

根目录下的 Makefile 聚合了项目所有的管理功能，这些管理功能通过 Makefile 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 Makefile 中，这样可以使得 Makefile 更容易维护。对于复杂的命令，则编写成独立的 shell 脚本，并在 Makefile 命令中调用这些 shell 脚本

需要注意：Makefile 通过 .PHONY 标识定义伪目标，定义伪目标一定要加 .PHONY 标识，否则当有同名的文件时，伪目标可能不会被执行

## 编写技巧

### 通配符与自动变量

Makefile 允许对目标进行类似正则运算的匹配，主要用到的通配符是 %

```
tools.verify.%:
  @if ! which $* &>/dev/null; then $(MAKE) tools.install.$*; fi
```

make tools.verify.swagger、make tools.verify.mockgen 等均可以使用上面定义的规则

另外，上面的定义中还用到了自动变量 `$*`，用来指代被匹配的值 swagger、mockgen

### 使用函数

Makefile 自带的函数能够实现很多强大的功能

### 依赖工具

如果 Makefile 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化

### 可扩展

1.  可以在不改变 Makefile 结构的情况下添加新功能
2.  扩展项目时，新功能可以自动纳入到 Makefile 现有逻辑中

### 统一输出

把输出文件统一放在一个目录下，方便后期的清理和查找

### 层级命令

通过使用带层级的命名方式，例如 tools.verify.swagger，可以实现目标分组管理。这样做有以下好处：

1.  当 Makefile 有大量目标时，通过分组可以更好地管理这些目标
2.  分组也能方便理解，可以通过组名一眼识别出该目标的功能类别
3.  可以大大减小目标重名的概率

### 目标拆分

比如，可以将安装工具拆分成两个目标：验证工具是否已安装和安装工具。通过这种方式，可以给 Makefile 带来更大的灵活性。比如，可以根据需要选择性地执行其中一个操作，也可以两个操作一起执行

### 设置 OPTIONS

把一些可变的功能通过 OPTIONS 来控制

### 环境变量

这些环境变量和编程中使用宏定义的作用是一样的，只要修改一处，就可以使很多地方同时生效，避免了重复的工作