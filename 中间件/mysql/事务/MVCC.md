## 快照

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 `transaction id`。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的

mysql 中一条记录有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本，并且把 `transaction id` 赋值给这个数据版本，记为 `row trx_id`。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本，每个版本有自己的 `row trx_id`

![[Pasted image 20230305213306.png]]

图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4。图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来

按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。在实现上，InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务 ID。活跃指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位

![[Pasted image 20230305213320.png]]

对于当前事务的启动瞬间来说，一个数据版本的 `row trx_id`，有以下几种可能：
1.  落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的
2.  落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的
3.  落在黄色部分，那就包括两种情况：
	1. 若 `row trx_id` 在数组中，表示这个版本是由还没提交的事务生成的，不可见
	2. 若 `row trx_id` 不在数组中，表示这个版本是已经提交了的事务生成的，可见

```
CREATE TABLE t (
    id int(11) NOT NULL,
    k int(11) DEFAULT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB;

insert into t (1, 1), (2, 2);
```

## 查询逻辑

![[Pasted image 20230305213446.png]]

需要明确一点，`begin/start transaction` 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句时，事务才真正启动。可以通过 `start transaction with consistent snapshot` 这个命令马上启动一个事务

事务 C 没有显示地使用 `begin/commit`，表示这个更新语句本身就是一个事务，执行完成后自动提交

在这里，不妨做如下假设：
1.  事务 A 开始前，系统里面只有一个活跃事务 ID 是 99
2.  事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务
3.  三个事务开始前，(1, 1) 这一行数据的 `row trx_id` 是 90。这样，事务 A 的视图数组就是 [99,100]，事务 B 的视图数组是 [99,100,101]，事务 C 的视图数组是 [99,100,101,102]

![[Pasted image 20230305213508.png]]

第一个有效更新是事务 C，把数据从 (1, 1) 改成了 (1, 2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本

第二个有效更新是事务 B，把数据从 (1, 2) 改成了 (1, 3)。这时候，这个数据的最新版本是 101，而 102 又成为了历史版本

现在，事务 A 开始读数据了，它的视图数组是 [99, 100]。读数据都是从当前版本读起的，所以，事务 A 查询语句的读数据流程是这样的：找到 (1, 3) 的时候，判断出 `row trx_id` 为 101，比高水位大，不可见；接着，找到上一个历史版本，`row trx_id` 为 `row trx_id` 为 90，比低水位小，可见。这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读

总结起来，启动一个数据库事务，会开启一个事务视图。除了自己的更新总是可以看见以外，还有三种情况：
1.  版本未提交，不可见
2.  版本已提交，但是在视图创建后提交的，不可见
3.  版本已提交，而且是视图创建前提交的，可见

## 更新逻辑

![[Pasted image 20230305213527.png]]

更新数据都是先读后写的，而这个读，只能读当前的值，称为当前读。因此，在更新的时候，当前读拿到的数据是 (1, 2)，更新后生成了新版本的数据 (1, 3)，这个新版本的 `row trx_id` 是 101。所以，在执行事务 B 查询语句的时候，发现最新数据的版本号就是自己的版本号 101，属于自己的更新，可以直接使用，所以查询得到的 k 的值是 3

表结构不支持可重复读，这是因为表结构没有对应的行数据，也没有 `row_trx_id`，因此只能遵循当前读的逻辑

其实，除了 update 语句外，select 语句如果加锁，也是当前读。所以，如果把事务 A 的查询语句加上 `lock in share mode` 或 `for update`，也都可以读到版本号是 101 的数据，返回的 k 的值是 3

```sql
select k from t where id = 1 lock in share mode;
select k from t where id = 1 for update;
```

![[Pasted image 20230305213554.png]]

事务 C' 更新后，生成最新版本 (1, 2)，并没有马上提交。在它提交前，事务 B 的更新语句先发起了。事务 C’ 没提交，也就是说 (1, 2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C‘ 释放这个锁，才能继续它的当前读

![[Pasted image 20230305213607.png]]

可重复读的核心就是一致性读，而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待

读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。`start transaction with consistent snapshot` 的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 `start transaction`

![[Pasted image 20230305213622.png]]

事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1, 2)、(1, 3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：(1, 3) 还没提交，不可见；(1, 2) 提交了，可见

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, c) values(1, 1), (2, 2), (3, 3), (4, 4);
```

![[Pasted image 20230305213642.png]]

事务更新语句已经执行成功，说明没有另外一个活动中的事务在执行修改条件为 `id in 1, 2, 3, 4` 或 `c in 1, 2, 3, 4`；否则更新会被锁阻塞。事务再次执行查询结果却是一样，说明说明另一个事务把 id 或者 c 修改了，而且已经提交了，导致事务当前读没有匹配到对应的条件。事务的查询语句说明了另外一个事务执行更新后，提交时间一定是在该事务第一条查询语句之后执行的

![[Pasted image 20230305213658.png]]

![[Pasted image 20230305213707.png]]