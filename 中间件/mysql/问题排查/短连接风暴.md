MySQL 建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。在数据库压力比较小的时候，这些额外的成本并不明显。但是，短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨

max_connections 参数，用来控制一个 MySQL 实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求。对于被拒绝连接的请求来说，从业务角度看就是数据库不可用。在机器负载比较高的时候，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有新建连接的话，就可能会超过 max_connections 的限制

遇到这种情况时，有以下解决办法：

1. **调高 max_connections 的值**

但这样做是有风险的，因为 max_connections 设置得太大，让更多的连接都可以进来，系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到 CPU 资源去执行业务的 SQL 请求

```sql
show variables like "%max_connections%";
```

2.  **先处理掉那些占着连接但是不工作的线程**

对于那些不需要保持的连接，我们可以通过 kill connection 主动踢掉。这个行为跟事先设置 wait_timeout 的效果是一样的。如果一个线程空闲超过 wait_timeout 的值，就会被 MySQL 直接断开连接

但是需要注意，在 show processlist 的结果里，踢掉显示为 sleep 的线程，可能是有损的

![[Pasted image 20230305151459.png]]

如果断开 session A 的连接，因为这时候 session A 还没有提交，所以 MySQL 只能按照回滚事务来处理；而断开 session B 的连接，就没什么大影响。所以，如果按照优先级来说，应该优先断开像 session B 这样的事务外空闲的连接

![[Pasted image 20230305151510.png]]

要看事务具体状态的话，可以查 information_schema 库的 innodb_trx 表

![[Pasted image 20230305151523.png]]

这个结果里，trx_mysql_thread_id=4，表示 id=4 的线程还处在事务中。如果是连接数过多，可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接

一个客户端处于 sleep 状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到报错。从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，MySQL 一直没恢复

3. **减少连接过程的消耗**

有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段

跳过权限验证的方法是：重启数据库，并使用 –skip-grant-tables 参数启动。这样，整个 MySQL 会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。但是，这种方法风险极高，不建议使用

在 MySQL 8.0 版本里，如果启用 –skip-grant-tables 参数，MySQL 会默认把 --skip-networking 参数打开，表示这时候数据库只能被本地的客户端连接