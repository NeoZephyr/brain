在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准

## 常见模型

### **哈希**

1.  Hash 索引指向的数据是无序的，只适用于等值查询，区间查询会很慢
2.  Hash 索引不支持联合索引的最左侧原则，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用
3.  Hash 索引不支持 ORDER BY 排序，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用
4.  Hash 索引不支持模糊查询
5.  在有大量重复键的情况下，效率不高

![[Pasted image 20230305155731.png]]

通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash

```sql
show variables like '%adaptive_hash_index';
```

### 有序数组

1.  适用于等值查询、区间查询
2.  更新数据成本太高，适用于存储静态数据

![[Pasted image 20230305155751.png]]

### 二叉搜索树

1.  当数据量大的时候，树的高度会比较高，查询会比较慢
2.  每个节点只存储一个记录，可能导致一次查询有很多次磁盘 IO

![[Pasted image 20230305155802.png]]

### B 树（Balance Tree）

1.  不再是二叉搜索，而是 m 叉搜索，高度能够大大降低
2.  叶子节点与非叶子节点，都存储数据。所有叶子节点位于同一层
3.  根节点的子节点的范围是 [2, m]。每个中间节点包含 k-1 个关键字和 k 个子节点。k 的取值范围为 [ceil(m/2), m]
4.  通过中序遍历，可以获得所有节点

### B+ 树

1.  非叶子节点不再存储数据，数据只存储在同一层的叶子节点上。因此非叶子节点只存储 key，同样大小的磁盘页能比 B 树存储更多索引
2.  叶子之间，增加了链表，可以通过遍历获取所有节点，不再需要中序遍历；范围查找，定位 min 与 max 之后，中间叶子节点，就是结果集
3.  叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的 PK，用于查询加速，适合内存存储

B+ 树和 B 树的差异

1.  子节点数等于关键字数
2.  非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）
3.  非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中
4.  所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接

B+ 树的优势

1.  B+ 树查询效率更稳定。因为 B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B 树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况
2.  B+ 树的查询效率更高，这是因为同样的磁盘页大小，B+ 树可以存储更多的节点关键字，因此 B+ 树比 B 深度更低，查询所需要的磁盘 I/O 更少
3.  在查询范围上，B+ 树的效率更高。这是因为所有关键字都出现在 B+ 树的叶子节点中，并通过有序链表进行了链接。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多

## **MyISAM**

1.  主键索引与普通索引没有本质差异
2.  只有非聚集索引，即索引与数据是分开存储的
3.  主键索引的叶子节点，存储主键与对应行记录的指针；普通索引的叶子结点，存储索引列与对应行记录的指针

## InnoDB

1.  每一个索引都对应一棵 B+ 树
2.  每一个表都会有聚集索引（主键索引），且只能有一个  
    1.1 如果表定义了主键，则主键就是聚集索引  
    1.2 如果表没有定义主键，则第一个非空 `unique` 列是聚集索引1.3 如果以上条件都不满足，则会创建一个隐藏的 `row id` 作为聚集索引
3.  主键索引的叶子节点会存储主键与数据行，即数据与索引在一起；非主键索引（二级索引）只会存储主键值。因此基于非主键索引的查询需要先扫描非主键索引树以找到对应主键键值，然后再扫描主键索引树，这个过程称为回表
4.  不建议使用类似字符串这种较长的列做主键，因为所有的普通索引都会存储主键，过长的主键会导致普通索引过于庞大
5.  当插入新值时，为了保持索引的有序性，要进行必要的维护。以 `id` 索引为例，插入一条记录，如果 `id` 要插入的索引数据页满了，就需要申请新的数据页，进行分页处理。同理，如果删除了数据，数据页的利用率变低，就需要合并
6.  建议使用趋势递增的列作为主键，因为是递增的，每次插入都是追加操作，这样不至于插入记录时引起大量索引分裂、记录行移动