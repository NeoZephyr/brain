```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

默认是可重复读隔离级别
可重复读隔离级别下，加锁单位是 next-key lock
查找过程中访问到的对象才会加锁
索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁
索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁
唯一索引上的范围查询会访问到不满足条件的第一个值为止

## 等值查询

### 唯一索引

![[Pasted image 20230305152442.png]]

1.  由于表 t 中没有 id=7 的记录，session A 加锁范围就是 (5,10]
2.  由于这是一个索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁，即最终加锁范围是 (5, 10)
3.  session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的

### 非唯一索引

![[Pasted image 20230305152500.png]]

1.  sessionA 的加锁范围是 (0, 5]
2.  由于 c 是普通索引，仅访问 c = 5 这一条记录是不能马上停下来的，需要继续向右遍历，查到 c = 10 为止，查询过程中访问到的都需要加锁，即给 (5, 10] 加锁
3.  同时，由于这是一个索引上面的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁，加锁范围变为 (5, 10)
4.  由于，只有访问到的对象才会加锁。这个查询使用覆盖索引，并不需要访问主键索引，因此主键索引上没有加任何锁，这样 sessionB 才能执行成功，sessionC 会被间隙锁锁住

可以看出，查询中 lock in share mode 只锁覆盖索引，如果换成 for update 就表示要更新数据，系统也会给主键索引上满足条件的行加上行锁

锁是加在索引上的，如果要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段

## 范围查询

### 主键索引

![[Pasted image 20230305152523.png]]

1.  开始执行的时候，要找到第一个 id=10 的行，加 next-key lock (5,10]
2.  由于是唯一索引（主键）上的等值条件，退化成行锁，只加了 id=10 这一行的行锁
3.  范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock (10,15]
4.  所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock (10,15]

需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断

### 非唯一索引

![[Pasted image 20230305152542.png]]

加锁规则跟主键索引范围锁唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock

### 非唯一索引排序

![[Pasted image 20230305152601.png]]

1.  由于是 order by c desc，第一个要定位的是索引 c 上最右边的 c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]
2.  在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 session B 的 insert 语句的原因
3.  在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 select *，所以会在主键 id 上加三个行锁

### 唯一索引 bug

![[Pasted image 20230305152619.png]]

session A 是一个范围查询，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了

但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上

## 非唯一索引上存在等值

```sql
insert into t values(30,10,30);
```

![[Pasted image 20230305152648.png]]

![[Pasted image 20230305152658.png]]

1.  session A 进行遍历，先访问第一个 c=10 的记录。加 (c=5, id=5) 到 (c=10, id=10) 的 next-key lock
2.  继续向后查找，直到碰到 (c=15, id=15) 这一行，循环才结束
3.  这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10, id=10) 到 (c=15, id=15) 的间隙锁

加锁区间如图所示：

![[Pasted image 20230305152710.png]]

## limit 语句加锁

![[Pasted image 20230305152721.png]]

delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引 c 上的加锁范围就变成了从（c=5, id=5) 到（c=10, id=30) 这个前开后闭区间

可以看到，(c=10, id=30）之后的这个间隙并没有在加锁范围里，因此 insert 语句插入 c=12 是可以执行成功的。因此，在删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更全，还可以减小加锁的范围

![[Pasted image 20230305152741.png]]

## 死锁

![[Pasted image 20230305152752.png]]

1.  session A 在索引 c 上加了 next-key lock (5, 10] 和间隙锁 (10, 15)
2.  session B 的 update 语句也要在索引 c 上加 next-key lock (5, 10] ，进入锁等待
3.  session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住
4.  由于出现了死锁，InnoDB 让 session B 回滚

看上去，session B 的 next-key lock 还没申请成功，session A 应该不会被锁住的。但实际情况下，session B 的加 next-key lock (5, 10] 操作，分成了两步：

1.  先是加 (5, 10) 的间隙锁，加锁成功
2.  然后加 c=10 的行锁，这时候才被锁住的

也就是说，在分析加锁规则的时候可以用 next-key lock 来分析。但具体执行的时候，是要分成间隙锁和行锁两段来执行的

如果是在读提交隔离级别下，语句执行过程中加上的行锁，在语句执行完成后，就要把不满足条件的行上的行锁直接释放了，不需要等到事务提交。也即是说，读提交隔离级别下，锁的范围更小，锁的时间更短