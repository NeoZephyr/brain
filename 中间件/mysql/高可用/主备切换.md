## 可靠性优先策略

![](https://cdn.nlark.com/yuque/0/2021/png/2938940/1630730607671-cb0a7741-bd64-4f3a-87c3-5707623d7633.png)

从状态 1 到状态 2 切换的详细过程是这样的：

1.  判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步
2.  把主库 A 改成只读状态，即把 readonly 设置为 true
3.  判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止
4.  把备库 B 改成可读写状态，也就是把 readonly 设置为 false
5.  把业务请求切到备库 B。这个切换流程，一般是由专门的 HA 系统来完成的

![[Pasted image 20230305150106.png]]

可以看到，这个切换流程中是有不可用时间的。因为在步骤 2 之后，主库 A 和备库 B 都处于 readonly 状态，也就是说这时系统处于不可写状态，直到步骤 5 完成后才能恢复。在这个不可用状态中，比较耗费时间的是步骤 3，可能需要耗费好几秒的时间

因此，需要在步骤 1 先做判断，确保 seconds_behind_master 的值足够小。否则，如果一开始主备延迟就长达 30 分钟就直接切换的话，系统的不可用时间就会长达 30 分钟

## 可用性优先策略

将可靠性优先策略中的步骤 4、5 调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库。这个切换流程，保证了系统几乎没有不可用时间，但是可能会出现数据不一致的情况

```sql
CREATE TABLE `t` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `c` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(c) values(1),(2),(3);
```

```sql
insert into t(c) values(4);
insert into t(c) values(5);
```

假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到 5 秒。在插入一条 c=4 的语句后，发起了主备切换。假设 binlog_format=mixed

![[Pasted image 20230305150148.png]]

切换流程：

1.  步骤 2 中，主库 A 执行完 insert 语句，插入了一行数据（4,4），之后开始进行主备切换
2.  步骤 3 中，由于主备之间有 5 秒的延迟，所以备库 B 还没来得及应用（4,4）这个中转日志，就开始接收客户端插入 c=5 的命令
3.  步骤 4 中，备库 B 插入了一行数据（4,5），并且把这个 binlog 发给主库 A
4.  步骤 5 中，备库 B 执行插入 c=4 这个中转日志，插入了一行数据（5,4）。而直接在备库 B 执行的插入 c=5 这个语句，传到主库 A，就插入了一行新数据（5, 5）
5.  最后的结果就是，主库 A 和备库 B 上出现了两行不一致的数据

如果设置 binlog_format=row，因为 row 格式在记录 binlog 的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错 duplicate key error 并停止

![[Pasted image 20230305150210.png]]

从上面的分析中，可以看出：使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。而使用 mixed 或者 statement 格式的 binlog 时，数据很可能悄悄地就不一致。大多数情况下，都建议使用可靠性优先策略

![[Pasted image 20230305150226.png]]

假设，主库 A 和备库 B 间的主备延迟是 30 分钟，这时候主库 A 掉电了，HA 系统要切换 B 作为主库。在主动切换的时候，采用可靠性优先策略的话，就必须得等到备库 B 的 seconds_behind_master=0 之后才能切换，这样系统就处于完全不可用的状态。如果直接切换到备库 B，由于中转日志还没有应用完成，会导致客户端查询看不到之前执行完成的事务

在满足数据可靠性的前提下，MySQL 高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高