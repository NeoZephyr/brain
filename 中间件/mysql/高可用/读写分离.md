![[Pasted image 20230305134649.png]]

客户端直连方案，少了一层 proxy 转发，所以查询性能稍微好一点，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息

带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，带 proxy 架构的整体就相对比较复杂

在一主多从的结构中，可能会有通过从库读到系统的一个过期状态。解决这个问题，有以下方案：
1.  强制走主库方案
2.  sleep 方案
3.  判断主备无延迟方案
4.  配合 semi-sync 方案
5.  等主库位点方案
6.  等 GTID 方案

## 强制走主库

将查询请求做分类：
1.  对于必须要拿到最新结果的请求，强制将其发到主库上
2.  对于可以读到旧数据的请求，才将其发到从库上

## Sleep 方案

主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据

## 无延迟方案

要确保备库无延迟，通常有以下三种：
1. 确保主备无延迟的方法是，每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0，那就必须等到这个参数变为 0 才能执行查询请。seconds_behind_master 的单位是秒，如果觉得精度不够，还可以采用对比位点和 GTID 的方法来确保主备无延迟（show slave status）

![[Pasted image 20230305135043.png]]

2.  对比位点确保主备无延迟：
	1.  Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点
	2.  Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点
	3.  如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成

3.  对比 GTID 集合确保主备无延迟：
	1.  Auto_Position=1，表示这对主备关系使用了 GTID 协议
	2.  Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合
	3.  Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。如果这两个集合相同，也表示备库接收到的日志都已经同步完成

对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。在执行查询请求之前，先判断从库是否同步完成的方法，相比于 sleep 方案，准确度提升了不少，但还是没有达到精确的程度。一个事务的 binlog 在主备库之间的状态：

1.  主库执行完成，写入 binlog，并反馈给客户端
2.  binlog 被从主库发送给备库，备库收到
3.  在备库执行 binlog 完

上面判断主备无延迟的逻辑，是备库收到的日志都执行完成了。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态

![[Pasted image 20230305135303.png]]

这时，主库上执行完成了三个事务 trx1、trx2 和 trx3，其中：trx1 和 trx2 已经传到从库，并且已经执行完成了；trx3 在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。如果这时候你在从库 B 上执行查询请求，按照上面的逻辑，从库认为已经没有同步延迟，但还是查不到 trx3 的。严格地说，就是出现了过期读

## semi-sync

半同步复制：
1.  事务提交的时候，主库把 binlog 发给从库
2.  从库收到 binlog 以后，发回给主库一个 ack，表示收到了
3.  主库收到这个 ack 以后，才能给客户端返回事务完成的确认

如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。在普通的异步复制模式下，如果主库掉电的时候，有些 binlog 还来不及发给从库，会导致系统数据丢失，而 semi-sync 则不会

但是 semi-sync + 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题

其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。实际上，回到最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到主备完全同步

![[Pasted image 20230305135804.png]]

图中备库 B 下的虚线框，分别表示 relaylog 和 binlog 中的事务。可以看到，图中从状态 1 到状态 4，一直处于延迟一个事务的状态。备库 B 一直到状态 4 都和主库 A 存在延迟，如果用上面必须等到无延迟才能查询的方案，select 语句直到状态 4 都不能被执行。但是，其实客户端是在发完 trx1 更新后发起的 select 语句，只需要确保 trx1 已经执行完成就可以执行 select 语句了。也就是说，如果在状态 3 执行查询请求，得到的就是预期结果了

semi-sync 配合判断主备无延迟的方案，存在两个问题：一主多从的时候，在某些从库执行查询请求会存在过期读的现象；在持续延迟的情况下，可能出现过度等待的问题

# 等主库位点

```sql
select master_pos_wait(file, pos[, timeout]);
```

这条命令的逻辑如下：
1.  它是在从库执行的
2.  参数 file 和 pos 指的是主库上的文件名和位置
3.  timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒

这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。当然，除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：如果执行期间，备库同步线程发生异常，则返回 NULL；如果等待超过 N 秒，就返回 -1；如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0

图中先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，可以使用这个逻辑：
1.  trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position
2.  选定一个从库执行查询语句
3.  在从库上执行 select master_pos_wait(File, Position, 1)
4.  如果返回值是 >=0 的正整数，则在这个从库执行查询语句
5.  否则，到主库执行查询语句

![[Pasted image 20230305145015.png]]

## GTID

```sql
select wait_for_executed_gtid_set(gtid_set, 1);
```

这条命令的逻辑是：
1.  等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0
2.  超时返回 1

在等位点的方案中，执行完事务后，还要主动去主库执行 show master status。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。这时，等 GTID 的执行流程就变成了：

1.  trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1
2.  选定一个从库执行查询语句；在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)
3.  如果返回值是 0，则在这个从库执行查询语句
4.  否则，到主库执行查询语句

![[Pasted image 20230305145049.png]]

在第一步中，trx1 事务更新完成后，从返回包直接获取这个事务的 GTID。为了能够让 MySQL 在执行事务后，返回包中带上 GTID，需要将参数 session_track_gtids 设置为 OWN_GTID，然后通过 [API 接口](https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html) mysql_session_track_get_first 从返回包解析出 GTID 的值即可

### 数据一致性

#### 异步复制

客户端提交 COMMIT 之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做不会影响主库写的效率，但可能会存在主库宕机，而 Binlog 还没有同步到从库的情况。这时从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务

#### 半同步复制

MySQL5.5 版本之后开始支持半同步复制的方式。客户端提交 COMMIT 之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了 Binlog，并且写入到中继日志中，再返回给客户端。这样提高了数据的一致性，但降低了主库写的效率。在 MySQL5.7 版本中还增加了一个 rpl_semi_sync_master_wait_for_slave_count 参数，可以对应答的从库数量进行设置，默认为 1，也就是说只要有 1 个从库进行了响应，就可以返回给客户端

#### 组复制

组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。首先将多个节点共同组成一个复制组，在执行读写事务的时候，需要通过一致性协议层的同意。而只读事务则不需要经过组内同意，直接 COMMIT 即可。在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性

### 日志同步流程

1.  在备库上通过 `change master` 命令，设置主库的 IP、端口、用户名、密码，以及 `binlog` 文件名和日志偏移量
2.  在备库上面执行 `start slave` 命令，这时候备库会启动两个线程，即 io_thread 与 sql_thread，其中 io_thread 负责与主库建立连接
3.  主库校验完用户名、密码后，开始按照备库传过来的位置，从本地读取 `binlog` 发给备库
4.  备库拿到 `binlog` 后，写到本地文件，称为中转日志 `relay log`
5.  sql_thread 读取中转日志，解析出日志里的命令执行