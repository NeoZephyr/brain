## 主备功能

1.  提高数据库的吞吐量
2.  读写分离，提高数据库并发处理能力
3.  数据备份
4.  具有高可用性，当主库出现故障或宕机的情况下，可以切换到从库上，保证服务的正常运行

## 主备原理

![[Pasted image 20230305150258.png]]

在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 只是将 A 的更新都同步过来，到本地执行，这样保证了节点 B 和 A 的数据一致性。当切换到状态 2 时，客户端读写访问的都是节点 B，而节点 A 是 B 的备库

在状态 1 中，虽然节点 B 没有被直接访问，但依然建议把节点 B 设置成只读（readonly）模式。主要有以下几点：

1.  一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作
2.  防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致
3.  可以用 readonly 状态，来判断节点的角色
4.  虽然备库设置成只读的，同步更新的线程拥有超级权限，是可以进行同步更新的

![[Pasted image 20230305150315.png]]

备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：

1.  在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及请求 binlog 的开始位置，这个位置包含文件名和日志偏移量
2.  在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接
3.  主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B
4.  备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）
5.  sql_thread 读取中转日志，解析出日志里的命令，并执行

## 循环复制

![[Pasted image 20230305150354.png]]

如果主备使用的是双 M 结构，业务逻辑在节点 A 上面更新了一条语句，然后将生产的 `binlog` 发给节点 B，节点 B 执行完这条更新语句之后也会生产 binlog。那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，就会出现循环复制的问题

```sql
-- 建议设置为 on，备库执行 relay log 后生成 binlog
show variables like "%log_slave_updates%";
```

MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。因此，可以用下面的逻辑，来解决两个节点间的循环复制的问题：

1.  规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系
2.  一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog
3.  每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志

## 主备延迟

1.  主库 A 执行完成一个事务，写入 binlog，时刻记为 T1
2.  把备库 B 接收完这个 binlog 的时刻记为 T2
3.  备库 B 执行完成这个事务，时刻记为 T3

同一个事务，主备延迟时间大约就是 T3 - T1，即主库与备库事务完成的时间之间的差值。可以在备库上执行以下命令查看延迟时间（seconds_behind_master）：

```sql
-- seconds_behind_master
show slave status;
```

seconds_behind_master 的计算方法是这样的：每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master

看上去，主备库机器的系统时间设置不一致，会导致主备延迟的值不准。但实际上是不会的，因为备库连接到主库的时候，会通过执行 SELECT UNIX_TIMESTAMP() 函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行 seconds_behind_master 计算的时候会自动扣掉这个差值

通常来说，网络正常的情况下，T2 - T1 的值非常小，也就是说日志从主库传给备库所需的时间是很短的。那么，主备延迟的主要来源是备库接收完 `binlog` 和执行完这个事务之间的时间差。因此，主备延迟最直接的表现是，备库消费 `relay log` 比主库生产 `binlog` 的速度要慢

主备延迟一般有以下原因：

1.  备库所在机器的性能要比主库所在的机器性能差。可以选择选择相同规格机器给主库和备库，并且做对称部署
2.  备库上进行大量分析查询导致备库压力大。可以选择一主多从，多个从库分担查询压力；然后通过 binlog 输出到外部系统，例如 hadoop 系统，让外部系统提供统计查询能力
3.  大事务。主库上必须等事务执行完成才会写入 `binlog`，再传给备库。比如一次性 delete 删除太多数据导致延迟。解决办法是；删除数据的时候，要控制每个事务删除的数据量，分成多次删除。还有大表 DDL 也会导致这种情况，建议使用 gh-ost 方案