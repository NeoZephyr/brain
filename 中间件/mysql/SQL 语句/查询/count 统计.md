## 实现方式

不同的存储引擎，count 有不同的实现方式：
1. MyISAM 中把一个表的总行数存储到磁盘上，因此 count 直接返回，效率很高（没有 where 过滤条件的情况下）
2. Innodb 在执行的时候，需要把数据一行一行地从存储引擎中读出来，然后累积计数

Innodb 没有采取与 MyISAM 一样的方式将计数存起来，这跟是由于多版本并发控制的原因，要返回的数据行数在同一时刻多个查询时是不同的。Innodb 默认是可重复读隔离级别，在代码上就是通过多版本并发控制，每一行记录都要判断自己是否对这个会话可见，因此对于 count 操作来说，只能把数据一行一行地读出来依次判断，可见的行才能够加到对应查询的总行数中

![[Pasted image 20230305220548.png]]

在 Innodb 中，主键索引的叶子节点是数据，而普通索引的叶子节点是主键值。所以，普通索引比主键索引树小很多，而 count 这样的操作，无论遍历哪个索引树结果逻辑都是一样的，优化器就会选择最小的那棵树进行遍历

`show table status` 命令的输出结果里面也有一个 TABLE_ROWS 用于显示这个表当前有多少行，而且这个命令执行很快。但是 TABLE_ROWS 是从这个采样估算得来的，很不准

count 查询有以下多种形式：
1. count(主键 id)：遍历整张表，取出每一行的 id 返回到 server 层，server 层判断不为空之后累加
2. count(1)：遍历整张表，但不取值，server 层按行累加
3. count(\*)：不取值，server 层按行累加，推荐使用

## 缓存计数

## 数据库存储计数

把这个计数直接放到数据库里单独的一张计数表中