```sql
CREATE TABLE t (
    c1 VARCHAR(10),
    c2 VARCHAR(10) NOT NULL,
    c3 CHAR(10),
    c4 VARCHAR(10)
) CHARSET=ascii ROW_FORMAT=COMPACT;

INSERT INTO t(c1, c2, c3, c4)
VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
```

## COMPACT

![[Pasted image 20230305220719.png]]

### 额外信息

这部分信息是服务器为了描述这条记录而额外添加的一些信息，这些额外信息分为 3 类，分别是变长字段长度列表、NULL值列表和记录头信息

#### 变长字段长度列表

变长字段中存储多少字节的数据是不固定的，所以在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来

在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放

因为 t 表的 c1、c2、c4 列都是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为 t 表中的各个列都使用的是 ascii 字符集，所以每个字符只需要 1 个字节来进行编码，最终第一行记录的变长字段长度列表表示的效果如下

`01 03 04`

由于第一行记录中 c1、c2、c4 列中的字符串占用的字节数比较小，用 1 个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示

1. 假设某个字符集中表示一个字符最多需要使用的字节数为 W，也就是使用 `SHOW CHARSET` 语句的结果中的 Maxlen 列（ascii 字符集中的 W 是 1）
2. 对于变长类型 VARCHAR(M) 来说，这种类型表示能存储最多M个字符，所以这个类型能表示的字符串最多占用的字节数就是 M × W
3. 假设它实际存储的字符串占用的字节数是 L

如果 M × W <= 255，使用 1 个字节来表示真正字符串占用的字节数
如果 M × W > 255，且 L <= 127，用 1 个字节来表示真正字符串占用的字节数
如果 M × W > 255，且 L > 127，用 2 个字节来表示真正字符串占用的字节数

InnoDB 在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于 255 时，可以认为只使用 1 个字节来表示真正字符串占用的字节数。如果某个变长字段允许存储的最大字节数大于 255，InnoDB 使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为 0，那该字节就是一个单独的字段长度，如果该字节的第一个位为 1，那该字节就是半个字段长度

对于一些占用字节数非常多的字段，导致该记录在单个页面中无法存储，InnoDB 会把一部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来

#### NULL 值列表

如果表中没有允许存储 NULL 的列，则 NULL值列表就不存在。否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列。MySQL规定 NULL 值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补 0

![[Pasted image 20230305220809.png]]

#### 记录头信息

由固定的 5 个字节组成。5 个字节也就是 40 个二进制位，不同的位代表不同的意思

### 真实数据

记录的真实数据除了自己定义的列的数据以外，MySQL 还会为每个记录默认的添加一些列

1. row_id 表示行 id，占用 6 个字节。InnoDB 表优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中没有 Unique 键，则 InnoDB 会为表默认添加 row_id 列作为主键
2. transaction_id 表示事务 id，占用 6 个字节
3. roll_pointer 表示回滚指针，占用 7 个字节

对于 CHAR 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表

## Redundant

Redundant 行格式是 MySQL5.0 之前用的一种行格式

![[Pasted image 20230305220836.png]]

Redundant 行格式的开头是字段长度偏移列表，表示该条记录中所有列的偏移信息都按照逆序存储到字段长度偏移列表

Redundant 行格式的记录头信息占用 6 字节，48 个二进制位

Redundant 行格式没有 NULL 值列表，而是将列对应的偏移量值的第一个比特位作为是否为 NULL 的依据

如果存储 NULL 值的字段是定长类型的（CHAR(M)），则 NULL 值也将占用记录的真实数据部分，并把该字段对应的数据使用 0x00 字节填充

如果存储 NULL 值的字段是变长数据类型的，则不在记录的真实数据处占用任何存储空间

在 Redundant 行格式中，使用 CHAR(M) 类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和 M 的乘积。例如，使用 utf8 字符集的 CHAR(10) 类型的列占用的真实数据空间始终为 30 个字节。由此可以看出来，使用 Redundant 行格式的 CHAR(M) 类型的列是不会产生碎片的

## 行溢出

MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节

例如，存储一个 VARCHAR(M) 类型的列，需要占用 3 部分存储空间：

1. 真实数据
2. 真实数据占用字节的长度
3. NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间

一个页的大小一般是 16KB，也就是 16384 字节。除去额外信息占用的字节，一个 VARCHAR(M) 类型的列就最多可以存储 65532 个字节，这样可能造成一个页存放不了一条记录

在 Compact 和 Redundant 行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据（前 768 个字节），把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用 20 个字节存储指向这些页的地址（这 20 个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页

除了 VARCHAR(M) 类型的列，TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出

## Dynamic

MySQL5.7 的默认行格式就是 Dynamic。这种行格式与 Compact 行格式类似，只是在处理行溢出数据时略有不同

Dynamic 不会在记录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址

## Compressed

Compressed 和 Dynamic 不同的一点是，Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间