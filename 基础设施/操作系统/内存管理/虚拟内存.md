## 分段机制

![[Pasted image 20221212230242.png]]
分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。段选择子保存段寄存器里面。段选择子里面的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址

例如，将虚拟空间分成 4 个段，用 0～3 来编号。每个段在段表中有一个项。如果要访问段 2 中偏移量 600 的虚拟地址，可以计算出物理地址为，段 2 基地址 2000 + 偏移量 600 = 2600
![[Pasted image 20221212230658.png]]

在 Linux 里面，段表全称段描述符表（segment descriptors），放在全局描述符表 GDT（Global Descriptor Table）里面

## 分页

操作系统把物理内存分成一块一块大小相同的页。如果有内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率

换入和换出都是以页为单位的，页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了
![[Pasted image 20221212231354.png]]

虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址

32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存

页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。可以将页表再分页，4G 的空间需要 4M 的页表来存储映射。把这 4M 分成 1K（1024）个 4K，这 1K 个页也需要一个表进行管理，称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K

页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置

映射 4GB 地址空间就需要 4MB + 4KB 的内存，看上去这种方法会占用更多的内存。如果页是满的，确实会占用更多的内存，但是，真实情况下不会为一个进程分配那么多内存。比如，只给这个进程分配了一个数据页。如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省了

![[Pasted image 20221212233028.png]]

对于 64 位的系统，两级不够用，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）

![[Pasted image 20221212233049.png]]